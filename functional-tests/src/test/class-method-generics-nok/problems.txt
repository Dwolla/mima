method genericWithChangingName()scala.Option in class A has a different signature in new version, where it is <T:Ljava/lang/Object;>()Lscala/Option<TT;>; rather than <U:Ljava/lang/Object;>()Lscala/Option<TU;>;. Note that the erased signature is still consistent. This means this change in the generics may or may not lead to problems at runtime, and possibly can be safely filtered out
method backwardsCompatibleNarrowing()scala.Option in class A has a different signature in new version, where it is ()Lscala/Option<Ljava/lang/String;>; rather than ()Lscala/Option<Ljava/lang/Object;>;. Note that the erased signature is still consistent. This means this change in the generics may or may not lead to problems at runtime, and possibly can be safely filtered out
#
method cov1()java.lang.Object in class Api has a different signature in new version, where it is <A:Ljava/lang/Object;>()TA; rather than <missing>. Note that the erased signature is still consistent. This means this change in the generics may or may not lead to problems at runtime, and possibly can be safely filtered out
method cov2()java.lang.Object in class Api has a different signature in new version, where it is <missing> rather than <T:Ljava/lang/Object;>()TT;. Note that the erased signature is still consistent. This means this change in the generics may or may not lead to problems at runtime, and possibly can be safely filtered out
method con1(java.lang.Object)Unit in class Api has a different signature in new version, where it is <A:Ljava/lang/Object;>(TA;)V rather than <missing>. Note that the erased signature is still consistent. This means this change in the generics may or may not lead to problems at runtime, and possibly can be safely filtered out
method con2(java.lang.Object)Unit in class Api has a different signature in new version, where it is <missing> rather than <T:Ljava/lang/Object;>(TT;)V. Note that the erased signature is still consistent. This means this change in the generics may or may not lead to problems at runtime, and possibly can be safely filtered out
#
abstract method cov1()java.lang.Object in class Abi has a different signature in new version, where it is <A:Ljava/lang/Object;>()TA; rather than <missing>. Note that the erased signature is still consistent. This means this change in the generics may or may not lead to problems at runtime, and possibly can be safely filtered out
abstract method cov2()java.lang.Object in class Abi has a different signature in new version, where it is <missing> rather than <T:Ljava/lang/Object;>()TT;. Note that the erased signature is still consistent. This means this change in the generics may or may not lead to problems at runtime, and possibly can be safely filtered out
abstract method con1(java.lang.Object)Unit in class Abi has a different signature in new version, where it is <A:Ljava/lang/Object;>(TA;)V rather than <missing>. Note that the erased signature is still consistent. This means this change in the generics may or may not lead to problems at runtime, and possibly can be safely filtered out
abstract method con2(java.lang.Object)Unit in class Abi has a different signature in new version, where it is <missing> rather than <T:Ljava/lang/Object;>(TT;)V. Note that the erased signature is still consistent. This means this change in the generics may or may not lead to problems at runtime, and possibly can be safely filtered out
